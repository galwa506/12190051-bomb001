Phase_2

//Before diffusing the bomb we need to set a break point at phase2 and at explode bomb function inorder to prevent the explosion of the bomb.
// We can set the break point with the help of the command either with "b" or "break" 

(gdb) b phase_2
Breakpoint 3 at 0x400ea9
(gdb) b explode_bomb
Breakpoint 4 at 0x40143d

//After setting the break point, we need to check if it's workinig fine.
//Here, I gave a string "hey" which is not exactly right but just to test if the bereak point is working fine.

(gdb) run ans1.txt
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/galey/Documents/5 sem/computer System1/labwork/Assignment 1_2/Assignment 1/bomb001/bomb ans1.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
a s

Breakpoint 3, 0x0000000000400ea9 in phase_2 () //This proves that the break point works.

//With the help of command "disas" We will be able to see the assembler code of phase_2 so that we can find the hidden code. 

(gdb) disas
Dump of assembler code for function phase_2:
=> 0x0000000000400ea9 <+0>:	push   %rbp
   0x0000000000400eaa <+1>:	push   %rbx
   0x0000000000400eab <+2>:	sub    $0x28,%rsp
   0x0000000000400eaf <+6>:	mov    %fs:0x28,%rax
   0x0000000000400eb8 <+15>:	mov    %rax,0x18(%rsp)
   0x0000000000400ebd <+20>:	xor    %eax,%eax
   0x0000000000400ebf <+22>:	mov    %rsp,%rsi
   0x0000000000400ec2 <+25>:	call   0x40145f <read_six_numbers>
   0x0000000000400ec7 <+30>:	cmpl   $0x0,(%rsp)
   0x0000000000400ecb <+34>:	jne    0x400ed4 <phase_2+43>
   0x0000000000400ecd <+36>:	cmpl   $0x1,0x4(%rsp)
   0x0000000000400ed2 <+41>:	je     0x400ed9 <phase_2+48>
   0x0000000000400ed4 <+43>:	call   0x40143d <explode_bomb>
   0x0000000000400ed9 <+48>:	mov    %rsp,%rbx
   0x0000000000400edc <+51>:	lea    0x10(%rsp),%rbp
   0x0000000000400ee1 <+56>:	mov    0x4(%rbx),%eax
   0x0000000000400ee4 <+59>:	add    (%rbx),%eax
   0x0000000000400ee6 <+61>:	cmp    %eax,0x8(%rbx)
   0x0000000000400ee9 <+64>:	je     0x400ef0 <phase_2+71>
   0x0000000000400eeb <+66>:	call   0x40143d <explode_bomb>
   0x0000000000400ef0 <+71>:	add    $0x4,%rbx
   0x0000000000400ef4 <+75>:	cmp    %rbp,%rbx
   0x0000000000400ef7 <+78>:	jne    0x400ee1 <phase_2+56>
   0x0000000000400ef9 <+80>:	mov    0x18(%rsp),%rax
   0x0000000000400efe <+85>:	xor    %fs:0x28,%rax
   0x0000000000400f07 <+94>:	je     0x400f0e <phase_2+101>
   0x0000000000400f09 <+96>:	call   0x400b00 <__stack_chk_fail@plt>
   0x0000000000400f0e <+101>:	add    $0x28,%rsp
   0x0000000000400f12 <+105>:	pop    %rbx
   0x0000000000400f13 <+106>:	pop    %rbp
   0x0000000000400f14 <+107>:	ret    
End of assembler dump.


//From line 28, we can figure out that the hidden code is a string as the function says "strings_not_equal".

//x command displays the memory contents at a given address using the specified format which in this case is a string.
//Here, we find the string which is in the esi register that has been moves to address 0x4023d0.
//So, we can conclude that the following string is the string we are looking for. 
(gdb) x/s 0x4023d0
0x4023d0:	"The moon unit will be divided into two divisions."

//After the hidden string has been discovered we delete all the breakpoint that we have set in the phase_1 as it is no longer required. 

//The hidden string is "The moon unit will be divided into two divisions."
